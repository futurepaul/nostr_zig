const std = @import("std");
const nostr_zig = @import("nostr_zig");
const crypto = nostr_zig.crypto;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    std.log.info("=== Testing Real BIP340 Schnorr Signatures ===", .{});

    // Create a client connected to the relay
    const relay_url = "ws://localhost:10547";
    var client = nostr_zig.Client.init(allocator, relay_url);
    defer client.deinit();

    // Connect to the relay
    std.log.info("Connecting to relay: {s}", .{relay_url});
    try client.connect();
    defer client.disconnect();
    std.log.info("âœ… Connected successfully!", .{});

    // Generate a real keypair
    std.log.info("Generating real secp256k1 keypair...", .{});
    const private_key = try crypto.generatePrivateKey();
    const public_key = try crypto.getPublicKey(private_key);
    const pubkey_hex = try crypto.bytesToHex(allocator, &public_key);
    defer allocator.free(pubkey_hex);
    std.log.info("âœ… Generated keypair. Pubkey: {s}...", .{pubkey_hex[0..16]});

    // Create event content
    const created_at = std.time.timestamp();
    const kind: u32 = 1;
    const tags = &[_][]const []const u8{
        &[_][]const u8{ "demo", "real-signatures" },
    };
    const content = "ğŸ‰ This event has REAL BIP340 Schnorr signatures generated by our custom secp256k1 integration!";

    // Calculate real event ID
    std.log.info("Calculating event ID...", .{});
    const event_id = try crypto.calculateEventId(allocator, pubkey_hex, created_at, kind, tags, content);
    defer allocator.free(event_id);
    std.log.info("âœ… Event ID: {s}", .{event_id});

    // Create real BIP340 Schnorr signature
    std.log.info("Creating BIP340 Schnorr signature...", .{});
    const signature = try crypto.signEvent(event_id, private_key);
    const sig_hex = try crypto.bytesToHex(allocator, &signature);
    defer allocator.free(sig_hex);
    std.log.info("âœ… Signature: {s}...", .{sig_hex[0..32]});

    // Verify signature locally
    std.log.info("Verifying signature locally...", .{});
    const is_valid = try crypto.verifySignature(event_id, signature, public_key);
    if (is_valid) {
        std.log.info("âœ… Local signature verification PASSED!", .{});
    } else {
        std.log.err("âŒ Local signature verification FAILED!", .{});
        return;
    }

    // Create the event
    const event = nostr_zig.Event{
        .id = event_id,
        .pubkey = pubkey_hex,
        .created_at = created_at,
        .kind = kind,
        .tags = tags,
        .content = content,
        .sig = sig_hex,
    };

    // Publish the event
    std.log.info("Publishing event to relay...", .{});
    
    const TestState = struct {
        event_accepted: bool = false,
        event_rejected: bool = false,
        relay_message: ?[]const u8 = null,
    };
    var state = TestState{};
    
    // Set up callback context
    const CallbackContext = struct {
        var test_state: *TestState = undefined;
        
        fn callback(ok: bool, message: ?[]const u8) void {
            if (ok) {
                std.log.info("ğŸ‰ RELAY ACCEPTED THE EVENT! Signature validation PASSED!", .{});
                test_state.event_accepted = true;
            } else {
                std.log.err("âŒ Relay rejected the event: {s}", .{message orelse "unknown reason"});
                test_state.event_rejected = true;
                test_state.relay_message = message;
            }
        }
    };
    CallbackContext.test_state = &state;
    
    try client.publish_event(event, CallbackContext.callback);

    // Wait for response
    std.log.info("Waiting for relay response...", .{});
    var attempts: u32 = 0;
    while (attempts < 100 and !state.event_accepted and !state.event_rejected) : (attempts += 1) {
        client.process_messages() catch |err| switch (err) {
            error.WouldBlock => {},
            else => return err,
        };
        std.time.sleep(50 * std.time.ns_per_ms);
    }

    if (state.event_accepted) {
        std.log.info("ğŸ‰ğŸ‰ğŸ‰ SUCCESS! The relay accepted our event with real BIP340 signatures! ğŸ‰ğŸ‰ğŸ‰", .{});
        std.log.info("This proves our secp256k1 integration is working correctly!", .{});
    } else if (state.event_rejected) {
        std.log.err("Relay rejected our event: {s}", .{state.relay_message orelse "unknown"});
    } else {
        std.log.warn("Timeout waiting for relay response", .{});
    }
}