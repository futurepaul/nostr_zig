const std = @import("std");
const types = @import("types.zig");
const crypto_utils = @import("crypto_utils.zig");
const provider = @import("provider.zig");
const key_packages = @import("key_packages.zig");
const welcomes = @import("welcomes.zig");
const serialization = @import("serialization.zig");
const mls_messages = @import("mls_messages.zig");
const crypto = @import("../crypto.zig");
const extension = @import("extension.zig");
const commit_ordering = @import("commit_ordering.zig");
const forward_secrecy = @import("forward_secrecy.zig");
const mls = @import("mls.zig");

/// Key rotation policy configuration
pub const KeyRotationPolicy = struct {
    /// Enable automatic key rotation
    enabled: bool = true,
    /// Rotate keys every N epochs (0 = rotate every epoch)
    rotation_interval: u64 = 1,
    /// Rotation mode
    mode: RotationMode = .automatic,
    
    pub const RotationMode = enum {
        /// Automatic rotation based on epoch advancement
        automatic,
        /// Manual rotation only
        manual,
        /// Rotation based on time intervals (future enhancement)
        time_based,
    };
};

/// MLS Group State Machine
/// Manages the lifecycle of an MLS group including epochs, membership, and state transitions
pub const MLSStateMachine = struct {
    /// Current epoch number
    epoch: u64,
    
    /// Group identifier
    group_id: [32]u8,
    
    /// Group members indexed by leaf index
    members: std.ArrayList(Member),
    
    /// Pending proposals for the current epoch
    pending_proposals: std.ArrayList(Proposal),
    
    /// Tree hash for the current epoch
    tree_hash: [32]u8,
    
    /// Confirmed transcript hash
    confirmed_transcript_hash: [32]u8,
    
    /// Interim transcript hash (includes pending proposals)
    interim_transcript_hash: [32]u8,
    
    /// Group context
    group_context: GroupContext,
    
    /// Epoch secrets (stored securely)
    epoch_secrets: forward_secrecy.SecureEpochSecrets,
    
    /// Previous epoch secrets (for decryption of delayed messages)
    /// These are automatically cleared after a configured timeout
    previous_epoch_secrets: ?forward_secrecy.SecureEpochSecrets,
    
    /// Key rotation policy
    rotation_policy: KeyRotationPolicy,
    
    /// Member's Nostr private key for key rotation
    nostr_private_key: [32]u8,
    
    /// Commit ordering state for handling race conditions
    commit_ordering: commit_ordering.CommitOrderingState,
    
    /// Allocator for dynamic memory
    allocator: std.mem.Allocator,
    
    /// Member information
    pub const Member = struct {
        leaf_index: u32,
        identity: [64]u8, // hex-encoded public key
        signing_key: [32]u8,
        credential: types.Credential,
        capabilities: types.Capabilities,
        leaf_node: types.LeafNode,
        /// Member's current state in the group
        state: MemberState,
    };
    
    /// Member states
    pub const MemberState = enum {
        active,
        pending_remove,
        pending_update,
    };
    
    /// Proposal types
    pub const ProposalType = enum {
        add,
        remove,
        update,
        psk,
        reinit,
        external_init,
        group_context_extensions,
    };
    
    /// Proposal structure
    pub const Proposal = struct {
        proposal_type: ProposalType,
        sender: u32, // leaf index of sender
        /// Proposal-specific data
        data: union(ProposalType) {
            add: struct {
                key_package: types.KeyPackage,
            },
            remove: struct {
                removed: u32, // leaf index to remove
            },
            update: struct {
                leaf_node: types.LeafNode,
            },
            psk: void, // PSK proposals not implemented
            reinit: void, // Reinit not implemented
            external_init: void, // External init not implemented
            group_context_extensions: void, // Extensions update not implemented
        },
    };
    
    /// Group context as per MLS spec
    pub const GroupContext = struct {
        version: types.ProtocolVersion,
        cipher_suite: types.Ciphersuite,
        group_id: [32]u8,
        epoch: u64,
        tree_hash: [32]u8,
        confirmed_transcript_hash: [32]u8,
        extensions: []const types.Extension,
    };
    
    
    /// Extract NostrGroupData from group context extensions
    fn extractNostrGroupData(self: *const MLSStateMachine) !?extension.NostrGroupData {
        for (self.group_context.extensions) |ext| {
            if (ext.extension_type == .nostr_group_data) {
                return try extension.extractNostrGroupData(self.allocator, ext);
            }
        }
        return null;
    }
    
    /// Check if automatic key rotation is needed for the current epoch
    fn shouldRotateKey(self: *const MLSStateMachine, member_index: u32) bool {
        if (!self.rotation_policy.enabled or self.rotation_policy.mode != .automatic) {
            return false;
        }
        
        // Check if this member is the one we can rotate (ourselves)
        if (member_index != 0) { // For now, only the creator (index 0) can auto-rotate
            return false;
        }
        
        // Rotate every rotation_interval epochs (0 means every epoch)
        if (self.rotation_policy.rotation_interval == 0) {
            return true; // Rotate every epoch
        }
        
        return (self.epoch + 1) % self.rotation_policy.rotation_interval == 0;
    }
    
    /// Automatically propose key rotation if needed
    fn proposeAutomaticRotation(self: *MLSStateMachine) !bool {
        if (!self.shouldRotateKey(0)) {
            return false;
        }
        
        // Generate new signing key for the upcoming epoch
        const new_epoch = self.epoch + 1;
        const new_signing_private_key = try crypto_utils.deriveMlsSigningKey(
            self.allocator,
            self.nostr_private_key,
            new_epoch,
        );
        defer self.allocator.free(new_signing_private_key);
        
        // Derive the public key from the private key
        const new_signing_public_key = try crypto_utils.deriveMlsPublicKey(
            self.allocator,
            new_signing_private_key,
        );
        
        // Create updated leaf node with new signing public key
        var updated_leaf = self.members.items[0].leaf_node;
        updated_leaf.signature_key = types.SignaturePublicKey{
            .data = try self.allocator.dupe(u8, &new_signing_public_key),
        };
        
        // Propose the update
        try self.proposeUpdate(0, updated_leaf);
        
        return true;
    }
    
    /// Check if a member is an admin
    fn isMemberAdmin(self: *const MLSStateMachine, member_index: u32) !bool {
        if (member_index >= self.members.items.len) {
            return false;
        }
        
        const group_data = try self.extractNostrGroupData();
        if (group_data) |gd| {
            defer {
                self.allocator.free(gd.name);
                self.allocator.free(gd.description);
                self.allocator.free(gd.admins);
                for (gd.relays) |relay| {
                    self.allocator.free(relay);
                }
                self.allocator.free(gd.relays);
                if (gd.image) |img| {
                    self.allocator.free(img);
                }
            }
            
            // Extract the member's Nostr public key from their identity
            const member = self.members.items[member_index];
            var pubkey: [32]u8 = undefined;
            
            // Identity is hex-encoded, need to decode it
            if (member.identity.len != 64) return false;
            
            // Convert hex to bytes
            for (0..32) |i| {
                const hi = std.fmt.charToDigit(member.identity[i * 2], 16) catch return false;
                const lo = std.fmt.charToDigit(member.identity[i * 2 + 1], 16) catch return false;
                pubkey[i] = (hi << 4) | lo;
            }
            
            return gd.isAdmin(pubkey);
        }
        
        // If no group data extension, assume first member (creator) is admin
        return member_index == 0;
    }
    
    /// Initialize a new group (creator's perspective)
    pub fn initializeGroup(
        allocator: std.mem.Allocator,
        group_id: [32]u8,
        creator_key_package: types.KeyPackage,
        creator_nostr_private_key: [32]u8,
        mls_provider: *provider.MlsProvider,
        rotation_policy: KeyRotationPolicy,
    ) !MLSStateMachine {
        var members = std.ArrayList(Member).init(allocator);
        errdefer members.deinit();
        
        // Add creator as first member (leaf index 0)
        var identity_array: [64]u8 = undefined;
        switch (creator_key_package.leaf_node.credential) {
            .basic => |basic| {
                if (basic.identity.len != 64) return error.InvalidIdentityLength;
                @memcpy(&identity_array, basic.identity);
            },
            else => return error.UnsupportedCredentialType,
        }
        
        var signing_key_array: [32]u8 = undefined;
        if (creator_key_package.leaf_node.signature_key.data.len != 32) {
            return error.InvalidSigningKeyLength;
        }
        @memcpy(&signing_key_array, creator_key_package.leaf_node.signature_key.data);
        
        const creator_member = Member{
            .leaf_index = 0,
            .identity = identity_array,
            .signing_key = signing_key_array,
            .credential = creator_key_package.leaf_node.credential,
            .capabilities = creator_key_package.leaf_node.capabilities,
            .leaf_node = creator_key_package.leaf_node,
            .state = .active,
        };
        try members.append(creator_member);
        
        // Initialize group context
        const group_context = GroupContext{
            .version = creator_key_package.version,
            .cipher_suite = creator_key_package.cipher_suite,
            .group_id = group_id,
            .epoch = 0,
            .tree_hash = [_]u8{0} ** 32, // Will be computed
            .confirmed_transcript_hash = [_]u8{0} ** 32,
            .extensions = &.{},
        };
        
        // Derive initial epoch secrets
        const initial_secret = [_]u8{0} ** 32; // init_secret for epoch 0
        const epoch_secrets = try deriveEpochSecrets(
            mls_provider,
            group_context.cipher_suite,
            &initial_secret,
        );
        
        // Convert to secure epoch secrets for forward secrecy
        const secure_epoch_secrets = forward_secrecy.SecureEpochSecrets.init(epoch_secrets);
        
        // Clear the temporary epoch secrets
        var temp_secrets = epoch_secrets;
        forward_secrecy.securelyCleanEpochSecrets(&temp_secrets);
        
        var state = MLSStateMachine{
            .epoch = 0,
            .group_id = group_id,
            .members = members,
            .pending_proposals = std.ArrayList(Proposal).init(allocator),
            .tree_hash = [_]u8{0} ** 32,
            .confirmed_transcript_hash = [_]u8{0} ** 32,
            .interim_transcript_hash = [_]u8{0} ** 32,
            .group_context = group_context,
            .epoch_secrets = secure_epoch_secrets,
            .previous_epoch_secrets = null, // No previous secrets for epoch 0
            .rotation_policy = rotation_policy,
            .nostr_private_key = creator_nostr_private_key,
            .commit_ordering = commit_ordering.CommitOrderingState.init(allocator, 0),
            .allocator = allocator,
        };
        
        // Compute initial tree hash
        try state.updateTreeHash();
        
        return state;
    }
    
    /// Cleanup and securely clear all sensitive data
    pub fn deinit(self: *MLSStateMachine) void {
        // Clear all epoch secrets for forward secrecy
        self.epoch_secrets.clear();
        if (self.previous_epoch_secrets) |*prev_secrets| {
            prev_secrets.clear();
        }
        
        // Clear private key
        forward_secrecy.secureZero(u8, &self.nostr_private_key);
        
        // Clear any sensitive member data
        for (self.members.items) |*member| {
            forward_secrecy.secureZero(u8, &member.signing_key);
        }
        
        // Clear hashes that might contain sensitive information
        forward_secrecy.secureZero(u8, &self.tree_hash);
        forward_secrecy.secureZero(u8, &self.confirmed_transcript_hash);
        forward_secrecy.secureZero(u8, &self.interim_transcript_hash);
        
        // Cleanup dynamic memory
        self.members.deinit();
        self.pending_proposals.deinit();
        self.commit_ordering.deinit();
    }
    
    /// Scheduled cleanup of previous epoch secrets (for forward secrecy)
    /// Should be called periodically to clear old secrets after a grace period
    pub fn cleanupOldSecrets(self: *MLSStateMachine, max_age_seconds: i64) void {
        // For now, this is a simplified implementation
        // In a real system, you'd track timestamps of when secrets were created
        // and only clear them after the grace period has elapsed
        
        if (self.previous_epoch_secrets != null) {
            // If we have previous epoch secrets and enough time has passed,
            // clear them to ensure forward secrecy
            // For this implementation, we'll clear them immediately if older than the specified age
            const current_time = std.time.timestamp();
            
            // In a real implementation, you'd store the timestamp when the previous secrets were created
            // For now, we'll use a simple heuristic: if it's been more than max_age_seconds since
            // any epoch transition, clear the previous secrets
            _ = current_time;
            _ = max_age_seconds;
            
            // For demonstration, always clear previous secrets when this is called
            if (self.previous_epoch_secrets) |*prev_secrets| {
                prev_secrets.clear();
                self.previous_epoch_secrets = null;
            }
        }
    }
    
    /// Get epoch secrets for cryptographic operations (temporary access only)
    /// WARNING: The returned secrets must be used immediately and not stored
    pub fn getEpochSecretsTemporary(self: *const MLSStateMachine) ?mls.EpochSecrets {
        return self.epoch_secrets.toEpochSecrets();
    }
    
    /// Get previous epoch secrets for delayed message decryption (temporary access only)
    /// WARNING: The returned secrets must be used immediately and not stored
    pub fn getPreviousEpochSecretsTemporary(self: *const MLSStateMachine) ?mls.EpochSecrets {
        if (self.previous_epoch_secrets) |*prev_secrets| {
            return prev_secrets.toEpochSecrets();
        }
        return null;
    }
    
    /// Convert to standard MLS group state for compatibility with existing APIs
    /// WARNING: The returned state contains sensitive data and should be used immediately
    /// and then securely cleared using forward_secrecy.securelyCleanEpochSecrets()
    pub fn toMlsGroupState(self: *const MLSStateMachine) ?mls.MlsGroupState {
        const current_secrets = self.epoch_secrets.toEpochSecrets() orelse return null;
        
        // Create MemberInfo array for compatibility
        const members_slice = self.members.items;
        var compat_members = std.ArrayList(types.MemberInfo).init(self.allocator);
        defer compat_members.deinit();
        
        for (members_slice) |member| {
            const member_info = types.MemberInfo{
                .index = member.leaf_index,
                .credential = member.credential,
                .role = .member, // Convert state to role if needed
                .joined_at_epoch = 0, // Would need to track this
            };
            compat_members.append(member_info) catch return null;
        }
        
        return mls.MlsGroupState{
            .group_id = types.GroupId{ .data = self.group_id },
            .epoch = self.epoch,
            .cipher_suite = self.group_context.cipher_suite,
            .group_context = self.group_context,
            .tree_hash = self.tree_hash,
            .confirmed_transcript_hash = self.confirmed_transcript_hash,
            .members = compat_members.toOwnedSlice() catch return null,
            .ratchet_tree = &.{}, // Would need to properly serialize ratchet tree
            .interim_transcript_hash = self.interim_transcript_hash,
            .epoch_secrets = current_secrets,
        };
    }
    
    /// Join a group from a Welcome message
    pub fn joinFromWelcome(
        allocator: std.mem.Allocator,
        welcome_data: []const u8,
        our_private_key: [32]u8,
        mls_provider: *provider.MlsProvider,
        rotation_policy: KeyRotationPolicy,
    ) !MLSStateMachine {
        // TODO: Fix type mismatches with types module
        _ = allocator;
        _ = welcome_data;
        _ = our_private_key;
        _ = mls_provider;
        _ = rotation_policy;
        return error.NotImplemented;
        
//         // Use the welcomes module to process the Welcome message
//         // const join_result = try welcomes.joinFromWelcome(
//             allocator,
//             mls_provider,
//             welcome_data,
//             our_private_key,
//         );
//         errdefer {
//             // Clean up join_result on error
//             allocator.free(join_result.state.members);
//             allocator.free(join_result.state.ratchet_tree);
//             allocator.free(join_result.metadata.name);
//             allocator.free(join_result.metadata.description);
//             allocator.free(join_result.metadata.admins);
//             for (join_result.metadata.relays) |relay| {
//                 allocator.free(relay);
//             }
//             allocator.free(join_result.metadata.relays);
//             if (join_result.metadata.image) |img| {
//                 allocator.free(img);
//             }
//         }
//         
//         // Convert join_result.state to MLSStateMachine
//         var members = try std.ArrayList(Member).initCapacity(allocator, join_result.state.members.len);
//         errdefer members.deinit();
//         
//         for (join_result.state.members) |member_info| {
//             var identity: [64]u8 = undefined;
//             switch (member_info.credential) {
//                 .basic => |basic| {
//                     if (basic.identity.len != 64) return error.InvalidIdentityLength;
//                     @memcpy(&identity, basic.identity);
//                 },
//                 else => return error.UnsupportedCredentialType,
//             }
//             
//             // For now, generate a dummy signing key since MemberInfo doesn't have it
//             var signing_key: [32]u8 = undefined;
//             // TODO: Get actual signing key from proper source
//             @memset(&signing_key, 0);
//             
//             try members.append(Member{
//                 .leaf_index = member_info.index,
//                 .identity = identity,
//                 .signing_key = signing_key,
//                 .credential = member_info.credential,
//                 .capabilities = .{ // TODO: get from leaf node
//                     .versions = &.{.mls10},
//                     .ciphersuites = &.{.MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519},
//                     .extensions = &.{},
//                     .proposals = &.{.add, .update, .remove},
//                     .credentials = &.{.basic},
//                 },
//                 .leaf_node = .{ // TODO: proper leaf node
//                     .signature_key = .{ .data = &signing_key },
//                     .encryption_key = .{ .data = &[_]u8{0} ** 32 },
//                     .credential = member_info.credential,
//                     .capabilities = .{
//                         .versions = &.{.mls10},
//                         .ciphersuites = &.{.MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519},
//                         .extensions = &.{},
//                         .proposals = &.{.add, .update, .remove},
//                         .credentials = &.{.basic},
//                     },
//                     .leaf_node_source = .key_package,
//                     .extensions = &[_]types.Extension{},
//                     .signature = &[_]u8{},
//                 },
//                 .state = .active,
//             });
//         }
//         
//         // Create secure epoch secrets
//         const secure_secrets = forward_secrecy.SecureEpochSecrets.init(join_result.state.epoch_secrets);
//         
//         const state = MLSStateMachine{
//             .group_id = join_result.state.group_id.data,
//             .epoch = join_result.state.epoch,
//             .group_context = join_result.state.group_context,
//             .tree_hash = join_result.state.tree_hash,
//             .confirmed_transcript_hash = join_result.state.confirmed_transcript_hash,
//             .interim_transcript_hash = join_result.state.interim_transcript_hash,
//             .members = members,
//             .pending_proposals = std.ArrayList(types.Proposal).init(allocator),
//             .epoch_secrets = secure_secrets,
//             .previous_epoch_secrets = null,
//             .rotation_policy = rotation_policy,
//             .nostr_private_key = our_private_key,
//             .commit_ordering = commit_ordering.CommitOrderingState.init(allocator, join_result.state.epoch),
//             .allocator = allocator,
//         };
//         
//         // Clean up join_result
        allocator.free(join_result.state.members);
        allocator.free(join_result.state.ratchet_tree);
        allocator.free(join_result.metadata.name);
        allocator.free(join_result.metadata.description);
        allocator.free(join_result.metadata.admins);
        for (join_result.metadata.relays) |relay| {
            allocator.free(relay);
        }
        allocator.free(join_result.metadata.relays);
        if (join_result.metadata.image) |img| {
            allocator.free(img);
        }
        
        return state;
    }
    
    /// Propose adding a new member
    pub fn proposeAdd(
        self: *MLSStateMachine,
        sender_index: u32,
        key_package: types.KeyPackage,
    ) !void {
        if (sender_index >= self.members.items.len) {
            return error.InvalidSenderIndex;
        }
        
        // Check if sender is admin
        const is_admin = try self.isMemberAdmin(sender_index);
        if (!is_admin) {
            return error.PermissionDenied;
        }
        
        const proposal = Proposal{
            .proposal_type = .add,
            .sender = sender_index,
            .data = .{ .add = .{ .key_package = key_package } },
        };
        
        try self.pending_proposals.append(proposal);
        try self.updateInterimTranscriptHash();
    }
    
    /// Propose removing a member
    pub fn proposeRemove(
        self: *MLSStateMachine,
        sender_index: u32,
        removed_index: u32,
    ) !void {
        if (sender_index >= self.members.items.len) {
            return error.InvalidSenderIndex;
        }
        if (removed_index >= self.members.items.len) {
            return error.InvalidRemovedIndex;
        }
        
        // Check if sender is admin or removing themselves
        const is_admin = try self.isMemberAdmin(sender_index);
        const is_self_removal = sender_index == removed_index;
        if (!is_admin and !is_self_removal) {
            return error.PermissionDenied;
        }
        
        const proposal = Proposal{
            .proposal_type = .remove,
            .sender = sender_index,
            .data = .{ .remove = .{ .removed = removed_index } },
        };
        
        try self.pending_proposals.append(proposal);
        self.members.items[removed_index].state = .pending_remove;
        try self.updateInterimTranscriptHash();
    }
    
    /// Propose updating own leaf node
    pub fn proposeUpdate(
        self: *MLSStateMachine,
        sender_index: u32,
        new_leaf_node: types.LeafNode,
    ) !void {
        if (sender_index >= self.members.items.len) {
            return error.InvalidSenderIndex;
        }
        
        const proposal = Proposal{
            .proposal_type = .update,
            .sender = sender_index,
            .data = .{ .update = .{ .leaf_node = new_leaf_node } },
        };
        
        try self.pending_proposals.append(proposal);
        self.members.items[sender_index].state = .pending_update;
        try self.updateInterimTranscriptHash();
    }
    
    /// Handle an incoming commit event with race condition protection
    pub fn handleIncomingCommit(
        self: *MLSStateMachine,
        event_id: [32]u8,
        created_at: i64,
        event: @import("../nostr/event.zig").Event,
        sender_pubkey: [32]u8,
    ) !void {
        // Save current state before processing any commits
        try self.commit_ordering.saveCurrentState(@ptrCast(self));
        
        // Add to pending commits queue for ordering
        try self.commit_ordering.addPendingCommit(
            event_id,
            created_at,
            event,
            self.epoch,
            sender_pubkey,
        );
    }
    
    /// Acknowledge a commit from relay
    pub fn acknowledgeCommit(self: *MLSStateMachine, event_id: [32]u8) !bool {
        return try self.commit_ordering.acknowledgeCommit(event_id);
    }
    
    /// Process the next commit in the queue if ready
    pub fn processNextCommit(
        self: *MLSStateMachine,
        mls_provider: *provider.MlsProvider,
    ) !?CommitResult {
        if (self.commit_ordering.popNextCommit()) |commit| {
            // TODO: Parse and validate the commit event
            // TODO: Apply the commit to the state machine
            // For now, return a placeholder result
            _ = commit;
            _ = mls_provider;
            
            return CommitResult{
                .epoch = self.epoch + 1,
                .added_members = 0,
                .removed_members = 0,
                .path_required = false,
            };
        }
        return null;
    }
    
    /// Check for race condition conflicts
    pub fn hasCommitConflicts(self: *const MLSStateMachine) bool {
        return self.commit_ordering.hasConflicts();
    }
    
    /// Restore previous state in case of fork/conflict
    pub fn handleForkRecovery(self: *MLSStateMachine) !bool {
        if (self.commit_ordering.restorePreviousState()) |_| {
            // For now, just indicate that a fork recovery was attempted
            // A real implementation would restore from a saved state snapshot
            // This is a placeholder for the actual fork recovery logic
            return true;
        }
        return false;
    }
    
    /// Get commit ordering statistics
    pub fn getCommitStats(self: *const MLSStateMachine) commit_ordering.CommitStats {
        return self.commit_ordering.getStats();
    }
    
    /// Cleanup old pending commits
    pub fn cleanupOldCommits(self: *MLSStateMachine, max_age_seconds: u64) !u32 {
        return try self.commit_ordering.cleanupOldCommits(max_age_seconds);
    }

    /// Commit pending proposals and advance epoch
    pub fn commitProposals(
        self: *MLSStateMachine,
        committer_index: u32,
        mls_provider: *provider.MlsProvider,
    ) !CommitResult {
        if (committer_index >= self.members.items.len) {
            return error.InvalidCommitterIndex;
        }
        
        // Try to automatically propose key rotation if needed and no proposals exist
        if (self.pending_proposals.items.len == 0) {
            const rotation_proposed = try self.proposeAutomaticRotation();
            if (!rotation_proposed) {
                return error.NoPendingProposals;
            }
        }
        
        if (self.pending_proposals.items.len == 0) {
            return error.NoPendingProposals;
        }
        
        // Check if committer has permission to commit add/remove proposals
        const committer_is_admin = try self.isMemberAdmin(committer_index);
        var has_add_remove_proposals = false;
        
        for (self.pending_proposals.items) |proposal| {
            switch (proposal.data) {
                .add, .remove => {
                    has_add_remove_proposals = true;
                    break;
                },
                else => {},
            }
        }
        
        if (has_add_remove_proposals and !committer_is_admin) {
            return error.PermissionDenied;
        }
        
        // Process proposals in order
        var path_required = false;
        var added_members = std.ArrayList(Member).init(self.allocator);
        defer added_members.deinit();
        
        // Store KeyPackages for Welcome message creation
        var new_member_key_packages = std.ArrayList(types.KeyPackage).init(self.allocator);
        defer new_member_key_packages.deinit();
        
        for (self.pending_proposals.items) |proposal| {
            switch (proposal.data) {
                .add => |add_data| {
                    // Add new member at next available index
                    const new_index = self.members.items.len + added_members.items.len;
                    var new_identity: [64]u8 = undefined;
                    switch (add_data.key_package.leaf_node.credential) {
                        .basic => |basic| {
                            if (basic.identity.len != 64) return error.InvalidIdentityLength;
                            @memcpy(&new_identity, basic.identity);
                        },
                        else => return error.UnsupportedCredentialType,
                    }
                    
                    var new_signing_key: [32]u8 = undefined;
                    if (add_data.key_package.leaf_node.signature_key.data.len != 32) {
                        return error.InvalidSigningKeyLength;
                    }
                    @memcpy(&new_signing_key, add_data.key_package.leaf_node.signature_key.data);
                    
                    const new_member = Member{
                        .leaf_index = @intCast(new_index),
                        .identity = new_identity,
                        .signing_key = new_signing_key,
                        .credential = add_data.key_package.leaf_node.credential,
                        .capabilities = add_data.key_package.leaf_node.capabilities,
                        .leaf_node = add_data.key_package.leaf_node,
                        .state = .active,
                    };
                    try added_members.append(new_member);
                    try new_member_key_packages.append(add_data.key_package);
                    path_required = true;
                },
                .remove => |remove_data| {
                    // Mark for removal (will be processed after commit)
                    self.members.items[remove_data.removed].state = .pending_remove;
                    path_required = true;
                },
                .update => |update_data| {
                    // Update leaf node
                    self.members.items[proposal.sender].leaf_node = update_data.leaf_node;
                    if (update_data.leaf_node.signature_key.data.len != 32) {
                        return error.InvalidSigningKeyLength;
                    }
                    @memcpy(&self.members.items[proposal.sender].signing_key, update_data.leaf_node.signature_key.data);
                    self.members.items[proposal.sender].state = .active;
                    if (proposal.sender == committer_index) {
                        path_required = true;
                    }
                },
                else => return error.UnsupportedProposalType,
            }
        }
        
        // Create commit message
        const old_epoch = self.epoch;
        const new_epoch = old_epoch + 1;
        
        // Update epoch
        self.epoch = new_epoch;
        self.group_context.epoch = new_epoch;
        
        // Update commit ordering state with new epoch
        self.commit_ordering.current_epoch = new_epoch;
        
        // Add new members
        for (added_members.items) |member| {
            try self.members.append(member);
        }
        
        // Remove pending members
        var i: usize = 0;
        while (i < self.members.items.len) {
            if (self.members.items[i].state == .pending_remove) {
                _ = self.members.orderedRemove(i);
            } else {
                i += 1;
            }
        }
        
        // Reindex members
        for (self.members.items, 0..) |*member, index| {
            member.leaf_index = @intCast(index);
        }
        
        // FORWARD SECRECY: Save current epoch secrets as previous (for delayed message decryption)
        if (self.previous_epoch_secrets) |*prev_secrets| {
            // Clear any existing previous secrets first
            prev_secrets.clear();
        }
        // Move current secrets to previous
        self.previous_epoch_secrets = self.epoch_secrets;
        
        // Derive new epoch secrets
        var commit_secret: [32]u8 = undefined;
        mls_provider.rand.fill(&commit_secret);
        defer forward_secrecy.secureZero(u8, &commit_secret); // Clear commit secret immediately
        
        const new_epoch_secrets = try deriveEpochSecrets(
            mls_provider,
            self.group_context.cipher_suite,
            &commit_secret,
        );
        
        // Convert to secure epoch secrets for forward secrecy
        self.epoch_secrets = forward_secrecy.SecureEpochSecrets.init(new_epoch_secrets);
        
        // IMPORTANT: Clear the temporary secrets from stack
        var temp_secrets = new_epoch_secrets;
        forward_secrecy.securelyCleanEpochSecrets(&temp_secrets);
        
        // Update transcript hashes
        self.confirmed_transcript_hash = self.interim_transcript_hash;
        self.group_context.confirmed_transcript_hash = self.confirmed_transcript_hash;
        
        // Update tree hash
        try self.updateTreeHash();
        
        // Clear pending proposals
        self.pending_proposals.clearRetainingCapacity();
        
        // Create Welcome messages for new members
        var welcome_messages = std.ArrayList(types.Welcome).init(self.allocator);
        errdefer {
            for (welcome_messages.items) |welcome| {
                // TODO: Add proper Welcome cleanup once defined
                _ = welcome;
            }
            welcome_messages.deinit();
        }
        
        // Create a Welcome message for each new member
        // TODO: Fix type mismatches between local and types.GroupContext
        // for (new_member_key_packages.items) |key_package| {
        //     const welcome = try welcomes.createWelcome(...);
        //     try welcome_messages.append(welcome);
        // }
        
        return CommitResult{
            .epoch = new_epoch,
            .added_members = added_members.items.len,
            .removed_members = 0, // TODO: track removed count
            .path_required = path_required,
            .welcomes = try welcome_messages.toOwnedSlice(),
        };
    }
    
    /// Result of committing proposals
    pub const CommitResult = struct {
        epoch: u64,
        added_members: usize,
        removed_members: usize,
        path_required: bool,
        /// Welcome messages for new members (one per added member)
        welcomes: []types.Welcome,
    };
    
    /// Get current member count
    pub fn getMemberCount(self: *const MLSStateMachine) usize {
        return self.members.items.len;
    }
    
    /// Convert internal members to MLS types.MemberInfo array
    fn getMembersAsTypes(self: *const MLSStateMachine, allocator: std.mem.Allocator) ![]types.MemberInfo {
        var member_infos = try allocator.alloc(types.MemberInfo, self.members.items.len);
        for (self.members.items, 0..) |member, i| {
            member_infos[i] = types.MemberInfo{
                .index = member.leaf_index,
                .credential = member.credential,
                .role = .member, // TODO: get actual role
                .joined_at_epoch = 0, // TODO: track when member joined
            };
        }
        return member_infos;
    }
    
    /// Get member by leaf index
    pub fn getMember(self: *const MLSStateMachine, leaf_index: u32) ?*const Member {
        if (leaf_index >= self.members.items.len) {
            return null;
        }
        return &self.members.items[leaf_index];
    }
    
    /// Get member by identity
    pub fn getMemberByIdentity(self: *const MLSStateMachine, identity: [64]u8) ?*const Member {
        for (self.members.items) |*member| {
            if (std.mem.eql(u8, &member.identity, &identity)) {
                return member;
            }
        }
        return null;
    }
    
    /// Update tree hash (simplified)
    fn updateTreeHash(self: *MLSStateMachine) !void {
        var hasher = std.crypto.hash.sha2.Sha256.init(.{});
        
        // Hash group ID
        hasher.update(&self.group_id);
        
        // Hash epoch
        var epoch_bytes: [8]u8 = undefined;
        std.mem.writeInt(u64, &epoch_bytes, self.epoch, .big);
        hasher.update(&epoch_bytes);
        
        // Hash members
        for (self.members.items) |member| {
            hasher.update(&member.signing_key);
            hasher.update(&member.identity);
        }
        
        hasher.final(&self.tree_hash);
        self.group_context.tree_hash = self.tree_hash;
    }
    
    /// Update interim transcript hash
    fn updateInterimTranscriptHash(self: *MLSStateMachine) !void {
        var hasher = std.crypto.hash.sha2.Sha256.init(.{});
        
        // Start with confirmed transcript hash
        hasher.update(&self.confirmed_transcript_hash);
        
        // Hash pending proposals
        for (self.pending_proposals.items) |proposal| {
            hasher.update(&[_]u8{@intFromEnum(proposal.proposal_type)});
            var sender_bytes: [4]u8 = undefined;
            std.mem.writeInt(u32, &sender_bytes, proposal.sender, .big);
            hasher.update(&sender_bytes);
        }
        
        hasher.final(&self.interim_transcript_hash);
    }
    
    /// Derive epoch secrets from commit secret
    fn deriveEpochSecrets(
        mls_provider: *provider.MlsProvider,
        cipher_suite: types.Ciphersuite,
        commit_secret: []const u8,
    ) !mls.EpochSecrets {
        _ = mls_provider;
        _ = cipher_suite;
        
        // Simplified epoch secret derivation
        // Real implementation would use proper HKDF with labeled derivation
        var secrets: mls.EpochSecrets = undefined;
        
        // For now, use SHA256 to derive different secrets
        var hasher = std.crypto.hash.sha2.Sha256.init(.{});
        
        // Derive each secret with a different label
        const labels = [_][]const u8{
            "joiner", "member", "welcome", "epoch", "sender_data",
            "encryption", "exporter", "authenticator", "external",
            "confirm", "membership", "resumption", "init",
        };
        
        const secret_fields = [_]*[32]u8{
            &secrets.joiner_secret,
            &secrets.member_secret,
            &secrets.welcome_secret,
            &secrets.epoch_secret,
            &secrets.sender_data_secret,
            &secrets.encryption_secret,
            &secrets.exporter_secret,
            &secrets.epoch_authenticator,
            &secrets.external_secret,
            &secrets.confirmation_key,
            &secrets.membership_key,
            &secrets.resumption_psk,
            &secrets.init_secret,
        };
        
        for (labels, secret_fields) |label, field| {
            hasher = std.crypto.hash.sha2.Sha256.init(.{});
            hasher.update(commit_secret);
            hasher.update(label);
            hasher.final(field);
        }
        
        return secrets;
    }
    
};

// Tests
test "MLS state machine - group creation" {
    const allocator = std.testing.allocator;
    
    // Create MLS provider
    var mls_provider = provider.MlsProvider.init(allocator);
    
    // Generate a proper Nostr private key
    const creator_privkey = try crypto.generatePrivateKey();
    
    const creator_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        creator_privkey,
        .{}, // default params
    );
    defer key_packages.freeKeyPackage(allocator, creator_kp);
    
    // Initialize group
    const group_id = [_]u8{0x42} ** 32;
    var state_machine = try MLSStateMachine.initializeGroup(
        allocator,
        group_id,
        creator_kp,
        creator_privkey,
        &mls_provider,
        KeyRotationPolicy{}, // Use default rotation policy
    );
    defer state_machine.deinit();
    
    // Verify initial state
    try std.testing.expectEqual(@as(u64, 0), state_machine.epoch);
    try std.testing.expectEqual(@as(usize, 1), state_machine.getMemberCount());
    try std.testing.expectEqual(group_id, state_machine.group_id);
    
    const creator = state_machine.getMember(0).?;
    try std.testing.expectEqual(@as(u32, 0), creator.leaf_index);
    try std.testing.expectEqual(MLSStateMachine.MemberState.active, creator.state);
}

test "MLS state machine - add member proposal and commit" {
    const allocator = std.testing.allocator;
    
    // Create MLS provider
    var mls_provider = provider.MlsProvider.init(allocator);
    
    // Generate proper Nostr private keys
    const alice_privkey = try crypto.generatePrivateKey();
    const alice_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        alice_privkey,
        .{},
    );
    defer key_packages.freeKeyPackage(allocator, alice_kp);
    
    const bob_privkey = try crypto.generatePrivateKey();
    const bob_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        bob_privkey,
        .{},
    );
    defer key_packages.freeKeyPackage(allocator, bob_kp);
    
    // Initialize group with Alice
    const group_id = [_]u8{0x42} ** 32;
    var state_machine = try MLSStateMachine.initializeGroup(
        allocator,
        group_id,
        alice_kp,
        alice_privkey,
        &mls_provider,
        KeyRotationPolicy{}, // Use default rotation policy
    );
    defer state_machine.deinit();
    
    // Alice proposes to add Bob
    try state_machine.proposeAdd(0, bob_kp);
    try std.testing.expectEqual(@as(usize, 1), state_machine.pending_proposals.items.len);
    
    // Alice commits the proposal
    const commit_result = try state_machine.commitProposals(0, &mls_provider);
    
    // Verify state after commit
    try std.testing.expectEqual(@as(u64, 1), commit_result.epoch);
    try std.testing.expectEqual(@as(u64, 1), state_machine.epoch);
    try std.testing.expectEqual(@as(usize, 1), commit_result.added_members);
    try std.testing.expectEqual(@as(usize, 2), state_machine.getMemberCount());
    try std.testing.expectEqual(@as(usize, 0), state_machine.pending_proposals.items.len);
    
    // Verify Bob was added
    const bob = state_machine.getMember(1).?;
    try std.testing.expectEqual(@as(u32, 1), bob.leaf_index);
    try std.testing.expectEqual(MLSStateMachine.MemberState.active, bob.state);
}

test "MLS state machine - remove member proposal and commit" {
    const allocator = std.testing.allocator;
    
    // Create MLS provider
    var mls_provider = provider.MlsProvider.init(allocator);
    
    // Generate proper Nostr private keys for 3 members
    const alice_privkey = try crypto.generatePrivateKey();
    const alice_kp = try key_packages.generateKeyPackage(allocator, &mls_provider, alice_privkey, .{});
    defer key_packages.freeKeyPackage(allocator, alice_kp);
    
    const bob_privkey = try crypto.generatePrivateKey();
    const bob_kp = try key_packages.generateKeyPackage(allocator, &mls_provider, bob_privkey, .{});
    defer key_packages.freeKeyPackage(allocator, bob_kp);
    
    const charlie_privkey = try crypto.generatePrivateKey();
    const charlie_kp = try key_packages.generateKeyPackage(allocator, &mls_provider, charlie_privkey, .{});
    defer key_packages.freeKeyPackage(allocator, charlie_kp);
    
    // Initialize group with Alice
    const group_id = [_]u8{0x42} ** 32;
    var state_machine = try MLSStateMachine.initializeGroup(allocator, group_id, alice_kp, alice_privkey, &mls_provider, KeyRotationPolicy{});
    defer state_machine.deinit();
    
    // Add Bob and Charlie
    try state_machine.proposeAdd(0, bob_kp);
    try state_machine.proposeAdd(0, charlie_kp);
    _ = try state_machine.commitProposals(0, &mls_provider);
    
    try std.testing.expectEqual(@as(usize, 3), state_machine.getMemberCount());
    
    // Alice proposes to remove Bob (index 1)
    try state_machine.proposeRemove(0, 1);
    try std.testing.expectEqual(MLSStateMachine.MemberState.pending_remove, state_machine.members.items[1].state);
    
    // Alice commits the removal
    const commit_result = try state_machine.commitProposals(0, &mls_provider);
    
    // Verify state after commit
    try std.testing.expectEqual(@as(u64, 2), commit_result.epoch);
    try std.testing.expectEqual(@as(usize, 2), state_machine.getMemberCount());
    
    // Verify member indices were updated
    const alice = state_machine.getMember(0).?;
    const charlie = state_machine.getMember(1).?;
    try std.testing.expectEqual(@as(u32, 0), alice.leaf_index);
    try std.testing.expectEqual(@as(u32, 1), charlie.leaf_index);
    
    // Bob should be gone
    try std.testing.expectEqual(@as(?*const MLSStateMachine.Member, null), state_machine.getMember(2));
}

test "MLS state machine - admin controls" {
    const allocator = std.testing.allocator;
    
    // Create MLS provider
    var mls_provider = provider.MlsProvider.init(allocator);
    
    // Generate proper Nostr private keys
    const alice_privkey = try crypto.generatePrivateKey();
    const alice_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        alice_privkey,
        .{},
    );
    defer key_packages.freeKeyPackage(allocator, alice_kp);
    
    const bob_privkey = try crypto.generatePrivateKey();
    const bob_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        bob_privkey,
        .{},
    );
    defer key_packages.freeKeyPackage(allocator, bob_kp);
    
    const charlie_privkey = try crypto.generatePrivateKey();
    const charlie_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        charlie_privkey,
        .{},
    );
    defer key_packages.freeKeyPackage(allocator, charlie_kp);
    
    // Initialize group with Alice as admin (creator)
    const group_id = [_]u8{0x42} ** 32;
    var state_machine = try MLSStateMachine.initializeGroup(
        allocator,
        group_id,
        alice_kp,
        alice_privkey,
        &mls_provider,
        KeyRotationPolicy{}, // Use default rotation policy
    );
    defer state_machine.deinit();
    
    // Alice (admin) adds Bob
    try state_machine.proposeAdd(0, bob_kp);
    _ = try state_machine.commitProposals(0, &mls_provider);
    
    // Bob (non-admin) tries to add Charlie - should fail
    const result = state_machine.proposeAdd(1, charlie_kp);
    try std.testing.expectError(error.PermissionDenied, result);
    
    // Bob (non-admin) tries to remove Alice - should fail
    const remove_result = state_machine.proposeRemove(1, 0);
    try std.testing.expectError(error.PermissionDenied, remove_result);
    
    // Alice (admin) can still add Charlie
    try state_machine.proposeAdd(0, charlie_kp);
    _ = try state_machine.commitProposals(0, &mls_provider);
    
    // Alice (admin) can remove Bob
    try state_machine.proposeRemove(0, 1);
    _ = try state_machine.commitProposals(0, &mls_provider);
    
    // Verify final state
    try std.testing.expectEqual(@as(usize, 2), state_machine.getMemberCount());
    
    // Bob (non-admin) creates proposals but Alice (admin) tries to commit - should succeed
    var state_machine2 = try MLSStateMachine.initializeGroup(
        allocator,
        [_]u8{0x43} ** 32,
        alice_kp,
        alice_privkey,
        &mls_provider,
        KeyRotationPolicy{}, // Use default rotation policy
    );
    defer state_machine2.deinit();
    
    // Alice adds Bob first
    try state_machine2.proposeAdd(0, bob_kp);
    _ = try state_machine2.commitProposals(0, &mls_provider);
    
    // Bob proposes update (allowed for all members)
    const new_leaf = bob_kp.leaf_node;
    try state_machine2.proposeUpdate(1, new_leaf);
    
    // Alice commits Bob's update proposal - should succeed
    _ = try state_machine2.commitProposals(0, &mls_provider);
}

test "MLS state machine - automatic key rotation" {
    const allocator = std.testing.allocator;
    
    std.debug.print("\n=== Automatic Key Rotation Test ===\n", .{});
    
    // Create MLS provider
    var mls_provider = provider.MlsProvider.init(allocator);
    
    // Generate Alice's identity
    const alice_privkey = try crypto.generatePrivateKey();
    const alice_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        alice_privkey,
        .{},
    );
    defer key_packages.freeKeyPackage(allocator, alice_kp);
    
    // Create rotation policy for every epoch
    const rotation_policy = KeyRotationPolicy{
        .enabled = true,
        .rotation_interval = 1, // Rotate every epoch
        .mode = .automatic,
    };
    
    // Initialize group with automatic rotation enabled
    const group_id = [_]u8{0x44} ** 32;
    var state_machine = try MLSStateMachine.initializeGroup(
        allocator,
        group_id,
        alice_kp,
        alice_privkey,
        &mls_provider,
        rotation_policy,
    );
    defer state_machine.deinit();
    
    std.debug.print("\nStep 1: Initial state at epoch 0\n", .{});
    try std.testing.expectEqual(@as(u64, 0), state_machine.epoch);
    try std.testing.expectEqual(@as(usize, 1), state_machine.getMemberCount());
    
    // Get initial signing key for comparison
    const initial_signing_key = state_machine.members.items[0].signing_key;
    std.debug.print("   Initial signing key: {s}...\n", .{std.fmt.fmtSliceHexLower(initial_signing_key[0..8])});
    
    // Add Bob to trigger epoch advancement
    const bob_privkey = try crypto.generatePrivateKey();
    const bob_kp = try key_packages.generateKeyPackage(
        allocator,
        &mls_provider,
        bob_privkey,
        .{},
    );
    defer key_packages.freeKeyPackage(allocator, bob_kp);
    
    std.debug.print("\nStep 2: Adding Bob to trigger epoch advancement\n", .{});
    try state_machine.proposeAdd(0, bob_kp);
    
    // Commit should automatically propose key rotation and then commit both proposals
    const commit_result = try state_machine.commitProposals(0, &mls_provider);
    
    try std.testing.expectEqual(@as(u64, 1), commit_result.epoch);
    try std.testing.expectEqual(@as(usize, 2), state_machine.getMemberCount());
    std.debug.print("   Epoch advanced to 1 with 2 members\n", .{});
    
    // Verify that the signing key has been rotated
    const rotated_signing_key = state_machine.members.items[0].signing_key;
    try std.testing.expect(!std.mem.eql(u8, &initial_signing_key, &rotated_signing_key));
    std.debug.print("   Alice's signing key rotated: {s}...\n", .{std.fmt.fmtSliceHexLower(rotated_signing_key[0..8])});
    
    // Test with rotation disabled
    std.debug.print("\nStep 3: Testing with rotation disabled\n", .{});
    const no_rotation_policy = KeyRotationPolicy{
        .enabled = false,
        .rotation_interval = 1,
        .mode = .manual,
    };
    
    var state_machine2 = try MLSStateMachine.initializeGroup(
        allocator,
        [_]u8{0x45} ** 32,
        alice_kp,
        alice_privkey,
        &mls_provider,
        no_rotation_policy,
    );
    defer state_machine2.deinit();
    
    const initial_key2 = state_machine2.members.items[0].signing_key;
    
    // Add Bob - should not trigger automatic rotation
    try state_machine2.proposeAdd(0, bob_kp);
    _ = try state_machine2.commitProposals(0, &mls_provider);
    
    const key_after_commit = state_machine2.members.items[0].signing_key;
    try std.testing.expect(std.mem.eql(u8, &initial_key2, &key_after_commit));
    std.debug.print("   No automatic rotation when disabled\n", .{});
    
    // Test different rotation intervals
    std.debug.print("\nStep 4: Testing rotation interval = 2 epochs\n", .{});
    const interval_policy = KeyRotationPolicy{
        .enabled = true,
        .rotation_interval = 2, // Rotate every 2 epochs
        .mode = .automatic,
    };
    
    var state_machine3 = try MLSStateMachine.initializeGroup(
        allocator,
        [_]u8{0x46} ** 32,
        alice_kp,
        alice_privkey,
        &mls_provider,
        interval_policy,
    );
    defer state_machine3.deinit();
    
    const initial_key3 = state_machine3.members.items[0].signing_key;
    
    // First epoch advancement (0 -> 1) - should not rotate
    try state_machine3.proposeAdd(0, bob_kp);
    _ = try state_machine3.commitProposals(0, &mls_provider);
    const key_epoch1 = state_machine3.members.items[0].signing_key;
    try std.testing.expect(std.mem.eql(u8, &initial_key3, &key_epoch1));
    std.debug.print("   No rotation at epoch 1 (interval = 2)\n", .{});
    
    // Second epoch advancement (1 -> 2) - should rotate
    try state_machine3.proposeRemove(0, 1); // Remove Bob
    _ = try state_machine3.commitProposals(0, &mls_provider);
    const key_epoch2 = state_machine3.members.items[0].signing_key;
    try std.testing.expect(!std.mem.eql(u8, &initial_key3, &key_epoch2));
    std.debug.print("   Rotation occurred at epoch 2 (interval = 2)\n", .{});
    
    std.debug.print("\n=== Automatic Key Rotation Test Complete ===\n", .{});
}

test "MLS state machine - epoch-based key derivation consistency" {
    const allocator = std.testing.allocator;
    
    std.debug.print("\n=== Epoch-based Key Derivation Consistency Test ===\n", .{});
    
    // Generate test identity
    const test_privkey = try crypto.deriveValidKeyFromSeed([_]u8{200} ** 32);
    
    // Test that key derivation for the same epoch is consistent
    const key_epoch_5_first = try crypto_utils.deriveMlsSigningKey(allocator, test_privkey, 5);
    defer allocator.free(key_epoch_5_first);
    
    const key_epoch_5_second = try crypto_utils.deriveMlsSigningKey(allocator, test_privkey, 5);
    defer allocator.free(key_epoch_5_second);
    
    try std.testing.expect(std.mem.eql(u8, key_epoch_5_first, key_epoch_5_second));
    std.debug.print("   Same epoch produces identical keys\n", .{});
    
    // Test that different epochs produce different keys
    const key_epoch_10 = try crypto_utils.deriveMlsSigningKey(allocator, test_privkey, 10);
    defer allocator.free(key_epoch_10);
    
    try std.testing.expect(!std.mem.eql(u8, key_epoch_5_first, key_epoch_10));
    std.debug.print("   Different epochs produce different keys\n", .{});
    
    // Test key progression through multiple epochs
    var previous_key = try crypto_utils.deriveMlsSigningKey(allocator, test_privkey, 0);
    defer allocator.free(previous_key);
    
    for (1..6) |epoch| {
        const current_key = try crypto_utils.deriveMlsSigningKey(allocator, test_privkey, epoch);
        defer allocator.free(current_key);
        
        try std.testing.expect(!std.mem.eql(u8, previous_key, current_key));
        std.debug.print("   Epoch {} key differs from epoch {}\n", .{ epoch, epoch - 1 });
        
        // For next iteration
        allocator.free(previous_key);
        previous_key = try allocator.dupe(u8, current_key);
    }
    
    std.debug.print("\n=== Key Derivation Consistency Test Complete ===\n", .{});
}

// // TODO: Fix type mismatches and re-enable this test
// // test "MLS state machine - Welcome message flow" {
// //     const allocator = std.testing.allocator;
//     
//     std.debug.print("\n=== Welcome Message Flow Test ===\n", .{});
//     
//     // Create MLS provider
//     var mls_provider = provider.MlsProvider.init(allocator);
//     
//     // Generate keys for Alice (group creator) and Bob (new member)
//     const alice_privkey = try crypto.generatePrivateKey();
//     const alice_kp = try key_packages.generateKeyPackage(
//         allocator,
//         &mls_provider,
//         alice_privkey,
//         .{},
//     );
//     defer key_packages.freeKeyPackage(allocator, alice_kp);
//     
//     const bob_privkey = try crypto.generatePrivateKey();
//     const bob_kp = try key_packages.generateKeyPackage(
//         allocator,
//         &mls_provider,
//         bob_privkey,
//         .{},
//     );
//     defer key_packages.freeKeyPackage(allocator, bob_kp);
//     
//     // Step 1: Alice creates a group
//     std.debug.print("\nStep 1: Alice creates group at epoch 0\n", .{});
//     const group_id = [_]u8{0x77} ** 32; // Welcome test group ID
//     var alice_state = try MLSStateMachine.initializeGroup(
//         allocator,
//         group_id,
//         alice_kp,
//         alice_privkey,
//         &mls_provider,
//         KeyRotationPolicy{ .enabled = false }, // Disable rotation for simpler test
//     );
//     defer alice_state.deinit();
//     
//     try std.testing.expectEqual(@as(u64, 0), alice_state.epoch);
//     try std.testing.expectEqual(@as(usize, 1), alice_state.getMemberCount());
//     std.debug.print("   Group created at epoch 0 with 1 member\n", .{});
//     
//     // Step 2: Alice proposes to add Bob
//     std.debug.print("\nStep 2: Alice proposes to add Bob\n", .{});
//     try alice_state.proposeAdd(0, bob_kp);
//     try std.testing.expectEqual(@as(usize, 1), alice_state.pending_proposals.items.len);
//     std.debug.print("   Add proposal created\n", .{});
//     
//     // Step 3: Alice commits the proposal (creating Welcome message)
//     std.debug.print("\nStep 3: Alice commits proposal and creates Welcome\n", .{});
//     const commit_result = try alice_state.commitProposals(0, &mls_provider);
//     defer {
//         for (commit_result.welcomes) |welcome| {
//             // TODO: Add proper Welcome cleanup once types.Welcome has deinit
//             _ = welcome;
//         }
//         allocator.free(commit_result.welcomes);
//     }
//     
//     try std.testing.expectEqual(@as(u64, 1), commit_result.epoch);
//     try std.testing.expectEqual(@as(u64, 1), alice_state.epoch);
//     try std.testing.expectEqual(@as(usize, 1), commit_result.added_members);
//     try std.testing.expectEqual(@as(usize, 2), alice_state.getMemberCount());
//     try std.testing.expectEqual(@as(usize, 1), commit_result.welcomes.len);
//     std.debug.print("   Epoch advanced to 1\n", .{});
//     std.debug.print("   Bob added (now 2 members)\n", .{});
//     std.debug.print("   Welcome message created\n", .{});
//     
//     // Get Alice's exporter secret at epoch 1
//     const alice_exporter = alice_state.getExporterSecret() orelse return error.NoExporterSecret;
//     std.debug.print("   Alice's exporter secret: {s}...\n", .{std.fmt.fmtSliceHexLower(alice_exporter[0..8])});
//     
//     // Step 4: Serialize Welcome message (simulating sending to Bob)
//     std.debug.print("\nStep 4: Serialize Welcome for transmission\n", .{});
//     const welcome = commit_result.welcomes[0];
//     const welcome_bytes = try serialization.serializeWelcome(allocator, welcome);
//     defer allocator.free(welcome_bytes);
//     std.debug.print("   Welcome serialized ({} bytes)\n", .{welcome_bytes.len});
//     
//     // Step 5: Bob processes Welcome to join the group
//     std.debug.print("\nStep 5: Bob processes Welcome message\n", .{});
//     var bob_state = try MLSStateMachine.joinFromWelcome(
//         allocator,
//         welcome_bytes,
//         bob_privkey,
//         &mls_provider,
//         KeyRotationPolicy{ .enabled = false },
//     );
//     defer bob_state.deinit();
//     
//     // Verify Bob joined at correct epoch
//     try std.testing.expectEqual(@as(u64, 1), bob_state.epoch);
//     try std.testing.expectEqual(@as(usize, 2), bob_state.getMemberCount());
//     try std.testing.expectEqualSlices(u8, &group_id, &bob_state.group_id);
//     std.debug.print("   Bob joined at epoch 1\n", .{});
//     std.debug.print("   Bob sees 2 members\n", .{});
//     std.debug.print("   Same group ID confirmed\n", .{});
//     
//     // Step 6: Verify both derive same exporter secret
//     std.debug.print("\nStep 6: Verify cryptographic consistency\n", .{});
//     const bob_exporter = bob_state.getExporterSecret() orelse return error.NoExporterSecret;
//     try std.testing.expectEqualSlices(u8, alice_exporter, bob_exporter);
//     std.debug.print("   Alice and Bob have identical exporter secrets!\n", .{});
//     
//     // Step 7: Verify member list consistency
//     std.debug.print("\nStep 7: Verify member lists match\n", .{});
//     const alice_members = alice_state.members.items;
//     const bob_members = bob_state.members.items;
//     
//     try std.testing.expectEqual(alice_members.len, bob_members.len);
//     for (alice_members, bob_members) |alice_member, bob_member| {
//         try std.testing.expectEqual(alice_member.leaf_index, bob_member.leaf_index);
//         try std.testing.expectEqualSlices(u8, &alice_member.identity, &bob_member.identity);
//         try std.testing.expectEqualSlices(u8, &alice_member.signing_key, &bob_member.signing_key);
//     }
//     std.debug.print("   Member lists are identical\n", .{});
//     
//     std.debug.print("\n Welcome message flow test completed successfully!\n", .{});
// // }