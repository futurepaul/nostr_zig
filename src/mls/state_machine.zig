const std = @import("std");
// Remove types.zig import - use mls_zig directly
const mls_zig = @import("mls_zig");
const tree_math = mls_zig.tree_math;
const crypto_utils = @import("crypto_utils.zig");
const provider = @import("provider.zig");
const key_packages = @import("key_packages.zig");
const crypto = @import("../crypto.zig");
const extension = @import("extension.zig");
const commit_ordering = @import("commit_ordering.zig");
const forward_secrecy = @import("forward_secrecy.zig");
const mls = @import("mls.zig");

// Use mls_zig types directly
pub const ProtocolVersion = mls_zig.ProtocolVersion;
pub const CipherSuite = mls_zig.CipherSuite;
pub const MlsGroupError = mls_zig.MlsGroupError;
pub const GroupContext = mls_zig.GroupContext;

/// Key rotation policy configuration
pub const KeyRotationPolicy = struct {
    /// Enable automatic key rotation
    enabled: bool = true,
    /// Rotate keys every N epochs (0 = rotate every epoch)
    rotation_interval: u64 = 1,
    /// Rotation mode
    mode: RotationMode = .automatic,
    
    pub const RotationMode = enum {
        /// Automatic rotation based on epoch advancement
        automatic,
        /// Manual rotation only
        manual,
        /// Rotation based on time intervals (future enhancement)
        time_based,
    };
};

/// Member state in the group
pub const MemberState = enum {
    active,
    pending,
    removed,
};

/// Information about a group member
pub const Member = struct {
    leaf_index: u32,
    state: MemberState = .active,
};

/// Commit result containing new state information
pub const CommitResult = struct {
    epoch: u64,
    secrets_rotated: bool,
    added_members: u32 = 0, // Count of members added in this commit
    path_required: bool = false, // Whether path update was required
};

/// MLS Group State Machine - Now a thin wrapper around mls_zig.MlsGroup
/// Manages the lifecycle of an MLS group including epochs, membership, and state transitions
pub const MLSStateMachine = struct {
    /// Core MLS group state (from mls_zig library) - Optional for now
    mls_group: ?mls_zig.MlsGroup,
    
    /// Allocator for memory management
    allocator: std.mem.Allocator,
    
    /// Nostr-specific private key (separate from MLS keys)
    nostr_private_key: [32]u8,
    
    /// Key rotation policy
    rotation_policy: KeyRotationPolicy,
    
    /// Commit ordering state for handling conflicts - Optional for now
    commit_ordering: ?commit_ordering.CommitOrderingState,
    
    /// Secure epoch secrets with forward secrecy
    epoch_secrets: forward_secrecy.SecureEpochSecrets,
    
    /// Previous epoch secrets (for forward secrecy demonstration)
    previous_epoch_secrets: ?forward_secrecy.SecureEpochSecrets,
    
    /// Legacy fields for WASM compatibility - computed from mls_group
    epoch: u64 = 0,
    members: std.ArrayList(u32),  // Member indices, computed from mls_group tree
    pending_proposals: std.ArrayList(u32),  // Pending proposal indices
    tree_hash: [32]u8 = [_]u8{0} ** 32,  // Tree hash from group context
    
    /// Initialize a new group as the founder
    pub fn initializeGroup(
        allocator: std.mem.Allocator,
        group_id: [32]u8,
        founder_key_package: anytype, // Our types.KeyPackage format (not actually used - we create fresh keys)
        nostr_private_key: [32]u8,
        mls_provider: anytype,
        rotation_policy: KeyRotationPolicy,
    ) !MLSStateMachine {
        _ = group_id; // Group ID is generated by mls_zig.MlsGroup.createGroup
        _ = founder_key_package; // We create a fresh KeyPackageBundle instead
        _ = mls_provider; // TODO: Use for crypto operations
        
        // Create a fresh KeyPackageBundle using mls_zig 
        // This approach is cleaner than trying to convert our existing one
        const cipher_suite = mls_zig.CipherSuite.MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519;
        
        // Create a credential from the nostr public key
        const nostr_pubkey = try crypto.getPublicKey(nostr_private_key);
        const identity_hex = try std.fmt.allocPrint(allocator, "{s}", .{std.fmt.fmtSliceHexLower(&nostr_pubkey)});
        defer allocator.free(identity_hex);
        
        var basic_credential = try mls_zig.BasicCredential.init(allocator, identity_hex);
        defer basic_credential.deinit();
        
        var credential = try mls_zig.Credential.fromBasic(allocator, &basic_credential);
        defer credential.deinit();
        
        // Create KeyPackageBundle using mls_zig
        const key_package_bundle = try mls_zig.KeyPackageBundle.init(
            allocator,
            cipher_suite,
            credential,
            null, // random function - use default
        );
        
        // Create MLS group using mls_zig (this takes ownership of the bundle)
        const mls_group = try mls_zig.MlsGroup.createGroup(
            allocator,
            cipher_suite,
            key_package_bundle,
            null, // random function - use default
        );
        
        // Initialize supporting structures
        const commit_ordering_state = commit_ordering.CommitOrderingState.init(allocator, 0);
        
        // Extract real epoch secrets from MLS group, or provide default values
        const epoch_secrets = if (mls_group.epoch_secrets) |mls_secrets| blk: {
            const real_epoch_secrets = mls.EpochSecrets{
                .joiner_secret = @bitCast(mls_secrets.joiner_secret.asSlice()[0..32].*),
                .member_secret = @bitCast(mls_secrets.epoch_secret.asSlice()[0..32].*),
                .welcome_secret = [_]u8{0} ** 32, // Not in mls_zig struct
                .epoch_secret = @bitCast(mls_secrets.epoch_secret.asSlice()[0..32].*),
                .sender_data_secret = @bitCast(mls_secrets.sender_data_secret.asSlice()[0..32].*),
                .encryption_secret = @bitCast(mls_secrets.encryption_secret.asSlice()[0..32].*),
                .exporter_secret = @bitCast(mls_secrets.exporter_secret.asSlice()[0..32].*),
                .epoch_authenticator = @bitCast(mls_secrets.authentication_secret.asSlice()[0..32].*),
                .external_secret = @bitCast(mls_secrets.external_secret.asSlice()[0..32].*),
                .confirmation_key = @bitCast(mls_secrets.confirmation_key.asSlice()[0..32].*),
                .membership_key = @bitCast(mls_secrets.membership_key.asSlice()[0..32].*),
                .resumption_psk = @bitCast(mls_secrets.resumption_psk.asSlice()[0..32].*),
                .init_secret = [_]u8{0} ** 32, // Not in mls_zig struct
            };
            break :blk forward_secrecy.SecureEpochSecrets.init(real_epoch_secrets);
        } else blk: {
            // Provide placeholder epoch secrets for initial state (will be updated when group has real secrets)
            const placeholder_secrets = mls.EpochSecrets{
                .joiner_secret = [_]u8{0x01} ** 32,
                .member_secret = [_]u8{0x02} ** 32,
                .welcome_secret = [_]u8{0x03} ** 32,
                .epoch_secret = [_]u8{0x04} ** 32,
                .sender_data_secret = [_]u8{0x05} ** 32,
                .encryption_secret = [_]u8{0x06} ** 32,
                .exporter_secret = [_]u8{0x07} ** 32,
                .epoch_authenticator = [_]u8{0x08} ** 32,
                .external_secret = [_]u8{0x09} ** 32,
                .confirmation_key = [_]u8{0x0A} ** 32,
                .membership_key = [_]u8{0x0B} ** 32,
                .resumption_psk = [_]u8{0x0C} ** 32,
                .init_secret = [_]u8{0x0D} ** 32,
            };
            break :blk forward_secrecy.SecureEpochSecrets.init(placeholder_secrets);
        };
        
        // Initialize member list with real member count from MLS tree
        var members = std.ArrayList(u32).init(allocator);
        const leaf_count = mls_group.tree.tree.leafCount();
        for (0..leaf_count) |i| {
            try members.append(@intCast(i));
        }
        
        // Initialize empty pending proposals list
        const pending_proposals = std.ArrayList(u32).init(allocator);
        
        var state_machine = MLSStateMachine{
            .mls_group = mls_group,
            .allocator = allocator,
            .nostr_private_key = nostr_private_key,
            .rotation_policy = rotation_policy,
            .commit_ordering = commit_ordering_state,
            .epoch_secrets = epoch_secrets,
            .previous_epoch_secrets = null,
            .epoch = 0,  // Initial epoch
            .members = members,
            .pending_proposals = pending_proposals,
        };
        
        // Update cached epoch from mls_group
        if (state_machine.mls_group) |group| {
            state_machine.epoch = group.epoch();
        }
        
        return state_machine;
    }
    
    /// Join an existing group from a Welcome message
    pub fn joinFromWelcome(
        allocator: std.mem.Allocator,
        welcome_data: []const u8,
        our_key_package_bundle: anytype, // Our KeyPackageBundle for decryption
        mls_provider: anytype,
        rotation_policy: KeyRotationPolicy,
    ) !MLSStateMachine {
        _ = mls_provider; // TODO: Use for crypto operations
        
        // First deserialize the welcome data into a Welcome struct
        const welcome = try mls_zig.mls_group.Welcome.deserialize(allocator, welcome_data);
        defer welcome.deinit(allocator);
        
        // Process the Welcome message using mls_zig (new 3-parameter signature)
        const mls_group = try mls_zig.MlsGroup.processWelcome(
            allocator,
            welcome,
            our_key_package_bundle
        );
        
        // Initialize supporting structures
        const commit_ordering_state = commit_ordering.CommitOrderingState.init(allocator, 0);
        
        // Extract real epoch secrets from MLS group, or provide default values
        const epoch_secrets = if (mls_group.epoch_secrets) |mls_secrets| blk: {
            const real_epoch_secrets = mls.EpochSecrets{
                .joiner_secret = @bitCast(mls_secrets.joiner_secret.asSlice()[0..32].*),
                .member_secret = @bitCast(mls_secrets.epoch_secret.asSlice()[0..32].*),
                .welcome_secret = [_]u8{0} ** 32, // Not in mls_zig struct
                .epoch_secret = @bitCast(mls_secrets.epoch_secret.asSlice()[0..32].*),
                .sender_data_secret = @bitCast(mls_secrets.sender_data_secret.asSlice()[0..32].*),
                .encryption_secret = @bitCast(mls_secrets.encryption_secret.asSlice()[0..32].*),
                .exporter_secret = @bitCast(mls_secrets.exporter_secret.asSlice()[0..32].*),
                .epoch_authenticator = @bitCast(mls_secrets.authentication_secret.asSlice()[0..32].*),
                .external_secret = @bitCast(mls_secrets.external_secret.asSlice()[0..32].*),
                .confirmation_key = @bitCast(mls_secrets.confirmation_key.asSlice()[0..32].*),
                .membership_key = @bitCast(mls_secrets.membership_key.asSlice()[0..32].*),
                .resumption_psk = @bitCast(mls_secrets.resumption_psk.asSlice()[0..32].*),
                .init_secret = [_]u8{0} ** 32, // Not in mls_zig struct
            };
            break :blk forward_secrecy.SecureEpochSecrets.init(real_epoch_secrets);
        } else blk: {
            // Provide placeholder epoch secrets for welcome joins (will be updated when group has real secrets)
            const placeholder_secrets = mls.EpochSecrets{
                .joiner_secret = [_]u8{0x11} ** 32,
                .member_secret = [_]u8{0x12} ** 32,
                .welcome_secret = [_]u8{0x13} ** 32,
                .epoch_secret = [_]u8{0x14} ** 32,
                .sender_data_secret = [_]u8{0x15} ** 32,
                .encryption_secret = [_]u8{0x16} ** 32,
                .exporter_secret = [_]u8{0x17} ** 32,
                .epoch_authenticator = [_]u8{0x18} ** 32,
                .external_secret = [_]u8{0x19} ** 32,
                .confirmation_key = [_]u8{0x1A} ** 32,
                .membership_key = [_]u8{0x1B} ** 32,
                .resumption_psk = [_]u8{0x1C} ** 32,
                .init_secret = [_]u8{0x1D} ** 32,
            };
            break :blk forward_secrecy.SecureEpochSecrets.init(placeholder_secrets);
        };
        
        // Get real member count from MLS group tree
        var members = std.ArrayList(u32).init(allocator);
        const leaf_count = mls_group.tree.tree.leafCount();
        for (0..leaf_count) |i| {
            try members.append(@intCast(i));
        }
        
        const pending_proposals = std.ArrayList(u32).init(allocator);
        
        // Extract the Nostr private key from the KeyPackageBundle
        // For now, since this is passed as anytype and we don't have the bundle here,
        // we'll need to pass the key separately or extract it from the credential
        var state_machine = MLSStateMachine{
            .mls_group = mls_group,
            .allocator = allocator,
            .nostr_private_key = [_]u8{0} ** 32, // TODO: Pass as separate parameter
            .rotation_policy = rotation_policy,
            .commit_ordering = commit_ordering_state,
            .epoch_secrets = epoch_secrets,
            .previous_epoch_secrets = null,
            .epoch = 0,  // Will be updated from mls_group
            .members = members,
            .pending_proposals = pending_proposals,
        };
        
        // Update cached epoch from mls_group
        if (state_machine.mls_group) |group| {
            state_machine.epoch = group.epoch();
        }
        
        return state_machine;
    }
    
    /// Propose adding a new member to the group
    pub fn proposeAdd(self: *MLSStateMachine, sender_index: u32, key_package: anytype) !void {
        _ = sender_index; // TODO: Use for validation
        
        if (self.mls_group) |*group| {
            // Check if we have a types.KeyPackage with serialized MLS data
            const has_mls_data = @hasField(@TypeOf(key_package), "mls_data");
            
            const mls_key_package = if (has_mls_data and key_package.mls_data != null) blk: {
                // We have serialized MLS data, deserialize it
                const data = key_package.mls_data.?;
                break :blk try mls_zig.KeyPackage.tlsDeserialize(self.allocator, data);
            } else if (@hasField(@TypeOf(key_package), "init_key")) blk: {
                // We have a simple types.KeyPackage, need to create full MLS KeyPackage
                const cipher_suite = mls_zig.CipherSuite.MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519;
                
                // Extract identity from the key package if available
                const identity = if (@hasField(@TypeOf(key_package), "leaf_node") and 
                                    @hasField(@TypeOf(key_package.leaf_node), "credential") and
                                    @hasField(@TypeOf(key_package.leaf_node.credential), "identity"))
                    key_package.leaf_node.credential.identity
                else
                    "unknown";
                
                // Create a basic credential
                var basic_credential = try mls_zig.BasicCredential.init(self.allocator, identity);
                defer basic_credential.deinit();
                
                var credential = try mls_zig.Credential.fromBasic(self.allocator, &basic_credential);
                defer credential.deinit();
                
                // Create temporary KeyPackageBundle to get a proper KeyPackage
                var key_package_bundle = try mls_zig.KeyPackageBundle.init(
                    self.allocator,
                    cipher_suite,
                    credential,
                    null, // random function - use default
                );
                
                // Extract the KeyPackage (ownership transfers to group)
                const kp = key_package_bundle.key_package;
                
                // Clean up private keys
                key_package_bundle.private_init_key.deinit();
                key_package_bundle.private_encryption_key.deinit();
                key_package_bundle.private_signature_key.deinit();
                
                break :blk kp;
            } else {
                return error.UnsupportedKeyPackageType;
            };
            
            // Transfer ownership of KeyPackage to the group
            try group.proposeAdd(mls_key_package);
            
            // Update cached epoch (proposals don't advance epoch until committed)
            self.epoch = group.epoch();
        } else {
            return error.InvalidGroupState;
        }
    }
    
    /// Propose updating a member's leaf node
    pub fn proposeUpdate(self: *MLSStateMachine, member_index: u32, leaf_node: anytype) !void {
        _ = member_index; // TODO: Use for validation
        _ = leaf_node; // TODO: Implement when mls_zig supports update proposals
        
        // TODO: mls_zig doesn't yet support proposeUpdate
        // For now, return an error until this is implemented
        _ = self;
        return error.UpdateProposalsNotSupported;
    }
    
    /// Propose removing a member from the group
    pub fn proposeRemove(self: *MLSStateMachine, sender_index: u32, member_index: u32) !void {
        _ = sender_index; // TODO: Use for validation
        
        if (self.mls_group) |*group| {
            // mls_zig uses LeafNodeIndex for member removal
            const leaf_index = tree_math.LeafNodeIndex.new(member_index);
            try group.proposeRemove(leaf_index);
            
            // Update cached epoch (proposals don't advance epoch until committed)
            self.epoch = group.epoch();
        } else {
            return error.InvalidGroupState;
        }
    }
    
    /// Commit pending proposals and advance epoch
    pub fn commitProposals(self: *MLSStateMachine, committer_index: u32, mls_provider: anytype) !CommitResult {
        _ = committer_index; // TODO: Use for validation
        _ = mls_provider; // TODO: Use for crypto operations
        
        if (self.mls_group) |*group| {
            const old_epoch = group.epoch();
            
            // Commit pending proposals using mls_zig
            _ = try group.commit(null); // random_fn parameter
            
            const new_epoch = group.epoch();
            const secrets_rotated = new_epoch > old_epoch;
            
            // Update cached epoch
            self.epoch = new_epoch;
            
            // Generate Welcome message if new members were added
            if (secrets_rotated) {
                var welcome = try group.generateWelcome();
                defer welcome.deinit();
                // Welcome message generated but not stored - just for protocol compliance
            }
            
            // Update epoch secrets from new MLS group state
            if (group.epoch_secrets) |mls_secrets| {
                const real_epoch_secrets = mls.EpochSecrets{
                    .joiner_secret = @bitCast(mls_secrets.joiner_secret.asSlice()[0..32].*),
                    .member_secret = @bitCast(mls_secrets.epoch_secret.asSlice()[0..32].*),
                    .welcome_secret = [_]u8{0} ** 32, // Not in mls_zig struct
                    .epoch_secret = @bitCast(mls_secrets.epoch_secret.asSlice()[0..32].*),
                    .sender_data_secret = @bitCast(mls_secrets.sender_data_secret.asSlice()[0..32].*),
                    .encryption_secret = @bitCast(mls_secrets.encryption_secret.asSlice()[0..32].*),
                    .exporter_secret = @bitCast(mls_secrets.exporter_secret.asSlice()[0..32].*),
                    .epoch_authenticator = @bitCast(mls_secrets.authentication_secret.asSlice()[0..32].*),
                    .external_secret = @bitCast(mls_secrets.external_secret.asSlice()[0..32].*),
                    .confirmation_key = @bitCast(mls_secrets.confirmation_key.asSlice()[0..32].*),
                    .membership_key = @bitCast(mls_secrets.membership_key.asSlice()[0..32].*),
                    .resumption_psk = @bitCast(mls_secrets.resumption_psk.asSlice()[0..32].*),
                    .init_secret = [_]u8{0} ** 32, // Not in mls_zig struct
                };
                self.epoch_secrets = forward_secrecy.SecureEpochSecrets.init(real_epoch_secrets);
            }
            
            // Update member list from MLS group tree
            self.members.clearRetainingCapacity();
            const leaf_count = group.tree.tree.leafCount();
            for (0..leaf_count) |i| {
                try self.members.append(@intCast(i));
            }
            
            return CommitResult{
                .epoch = new_epoch,
                .secrets_rotated = secrets_rotated,
            };
        } else {
            return error.InvalidGroupState;
        }
    }
    
    /// Get current group information
    pub fn getMemberCount(self: *const MLSStateMachine) u32 {
        return @intCast(self.members.items.len);
    }
    
    /// Get member by index
    pub fn getMember(self: *const MLSStateMachine, index: u32) ?Member {
        if (index >= self.members.items.len) return null;
        return Member{
            .leaf_index = self.members.items[index],
            .state = .active,
        };
    }
    
    /// Get current epoch
    pub fn getEpoch(self: *const MLSStateMachine) u64 {
        return self.epoch;  // Return cached value that's updated when group changes
    }
    
    /// Get group ID
    pub fn getGroupId(self: *const MLSStateMachine) []const u8 {
        _ = self;
        return ""; // TODO: return self.mls_group.group_context.group_id.data;
    }
    
    /// Clean up resources
    pub fn deinit(self: *MLSStateMachine) void {
        if (self.mls_group) |*mls_group| {
            mls_group.deinit();
        }
        if (self.commit_ordering) |*commit_ordering_state| {
            commit_ordering_state.deinit();
        }
        // Clean up members list and pending proposals
        self.members.deinit();
        self.pending_proposals.deinit();
        // Secure cleanup of secrets
        forward_secrecy.secureZero(u8, @as([*]u8, @ptrCast(&self.epoch_secrets))[0..@sizeOf(forward_secrecy.SecureEpochSecrets)]);
        if (self.previous_epoch_secrets) |*prev| {
            forward_secrecy.secureZero(u8, @as([*]u8, @ptrCast(prev))[0..@sizeOf(forward_secrecy.SecureEpochSecrets)]);
        }
    }
};